<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2020/04/04/about/</url>
    <content><![CDATA[<blockquote>
<p>A Coder, live in BJ, China.</p>
</blockquote>
<p>姓名：石帮玉<br>现居：北京<br>QQ: <a href="http://wpa.qq.com/msgrd?v=3&uin=2427075279&site=qq&menu=yes" target="_blank" rel="noopener">2427075279</a><br>微信: shi2427075279</p>
<a id="more"></a>]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_01</title>
    <url>/2020/04/22/linux-01/</url>
    <content><![CDATA[<h3 id="每日一条linux命令之ls"><a href="#每日一条linux命令之ls" class="headerlink" title="每日一条linux命令之ls"></a>每日一条linux命令之<strong>ls</strong></h3><p>ls命令是linux最常用的命令，它是list的缩写，主要用来打印当前目录下的文件夹及文件清单，除此之外还可以查看文件权限和文件的信息等等。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>ls [选项] [目录名]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>打印出目标目录下的所有的子目录及问件</p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>-a  列出目标目录下的所有文件夹和文件，包括.开头的隐藏文件</p>
<p>-A  同-a，但不列出隐藏文件</p>
<p>-g  类似 -l,但不列出所有者</p>
<p>-h  以容易理解的格式列出文件大小 (例如 1K 234M 2G)</p>
<p>–si 类似 -h,但文件大小取 1000 的次方而不是 1024</p>
<p>-H  使用命令列中的符号链接指示的真正目的地</p>
<p>-l  除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</p>
<p>-r  依相反次序排列</p>
<p>-R  同时列出所有子目录层</p>
<p>-t  以文件修ls改时间排序</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_02</title>
    <url>/2020/04/23/linux-02/</url>
    <content><![CDATA[<h3 id="每日一条linux命令之cd"><a href="#每日一条linux命令之cd" class="headerlink" title="每日一条linux命令之cd"></a>每日一条linux命令之<strong>cd</strong></h3><p>cd命令是linux最基本的命令，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。</p>
<p>所以，学习Linux 常用命令，首先就要学好 cd 命令的使用方法技巧。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>cd [目录名]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>切换目录</p>
<h4 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h4><p>进入系统根目录: cd /  或者  cd ../.. //</p>
<p>查看当前目录路径: pwd</p>
<p>返回上级目录: cd ..</p>
<p>进入当前用户的主目录: cd 或者 cd ~</p>
<p>跳转到指定目录: cd /opt/publish</p>
<p>返回进入此目录之前所在的目录: cd -</p>
<p>把上个命令的参数作为cd参数使用: cd !$</p>
<p>例: cp something /usr/local/xxx  —&gt;  cd !$  直接就进入了xxx目录。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>java存储区域</title>
    <url>/2020/04/07/java-memory/</url>
    <content><![CDATA[<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">位置</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器</td>
<td align="center">处理器内部</td>
<td align="center">快，不能人为控制</td>
</tr>
<tr>
<td align="center">堆栈</td>
<td align="center">RAM</td>
<td align="center">有点快，常用于存储句柄，基本数据类型</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">RAM</td>
<td align="center">存放对象，灵活，存储分配和清理较耗费时间</td>
</tr>
<tr>
<td align="center">静态存储</td>
<td align="center">RAM的固定位置</td>
<td align="center">用static指定</td>
</tr>
<tr>
<td align="center">常数存储</td>
<td align="center">程序代码内部</td>
<td align="center">字符串常量和基本类型常量</td>
</tr>
<tr>
<td align="center">非RAM存储</td>
<td align="center">非RAM</td>
<td align="center">-</td>
</tr>
</tbody></table>
<a id="more"></a>

<hr>
<h2 id="1-几种存储位置"><a href="#1-几种存储位置" class="headerlink" title="1.几种存储位置"></a>1.几种存储位置</h2><h3 id="1-1-寄存器"><a href="#1-1-寄存器" class="headerlink" title="1.1 寄存器"></a>1.1 寄存器</h3><p>最快的存储区域，位于处理器内部，所以数量非常有限。它是由编译器来进行分配，我们对此没有控制权。</p>
<h3 id="1-2-堆栈"><a href="#1-2-堆栈" class="headerlink" title="1.2 堆栈"></a>1.2 堆栈</h3><p>位于RAM当中，通过堆栈指针可以从处理器获得直接支持。堆栈指针向下移动，则分配新的内存；向上移动，则释放那些内存。这种存储方式速度仅次于寄存器。（常用于存放对象引用和基本数据类型，而不用于存储对象）</p>
<h3 id="1-3-堆"><a href="#1-3-堆" class="headerlink" title="1.3 堆"></a>1.3 堆</h3><p>一种通用的内存池，也位于RAM当中。其中存放的数据由JVM自动进行管理。<br>堆相对于栈的好处来说：编译器不需要知道存储的数据在堆里存活多长。当需要一个对象时，使用new写一行代码，当执行这行代码时，会自动在堆里进行存储分配。同时，因为以上原因，用堆进行数据的存储分配和清理，需要花费更多的时间。（常用于存储对象）</p>
<h3 id="1-4-静态存储"><a href="#1-4-静态存储" class="headerlink" title="1.4 静态存储"></a>1.4 静态存储</h3><p>“静态”是指位于RAM内的固定位置，程序运行期间，该区域的数据将随时等候被调用。可以用<em>static</em>关键字来制定该数据是静态的。</p>
<h3 id="1-5-常数存储"><a href="#1-5-常数存储" class="headerlink" title="1.5 常数存储"></a>1.5 常数存储</h3><p>常量(字符串常量和基本类型常量)通常直接存储在程序代码内部（常量池）。这样做是安全的，因为它们的值在初始化时就已经被确定，并不会被改变。常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s = “java”这种申明方式。</p>
<h3 id="1-6-非RAM存储"><a href="#1-6-非RAM存储" class="headerlink" title="1.6 非RAM存储"></a>1.6 非RAM存储</h3><p>如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是：流对象和持久化对象。在流对象中，对象转化为字节流，通常被发送给另一台机器。在持久化对象中，对象被存放在磁盘上。因此，即使程序终止，它们仍可以保持自己的状态。</p>
<hr>
<h2 id="2-堆和堆栈的对比"><a href="#2-堆和堆栈的对比" class="headerlink" title="2.堆和堆栈的对比"></a>2.堆和堆栈的对比</h2><h3 id="2-1-相同点和不同点"><a href="#2-1-相同点和不同点" class="headerlink" title="2.1 相同点和不同点"></a>2.1 相同点和不同点</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><p>堆和堆栈都是位于RAM（内存）内的存储区域，java会自动地管理堆和堆栈，不能人为控制。</p>
<h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><ul>
<li>存储数据类型：栈内存中存放局部变量（基本数据类型和对象引用)，而堆内存用于存放对象（实体）。</li>
<li>存储速度：就存储速度而言，栈内存的存储分配与清理速度更快于堆，并且栈内存的存储速度仅次于直接位于处理器当中的寄存器。</li>
<li>灵活性：就灵活性而言，由于栈内存与堆内存存储机制的不同，堆内存灵活性更优于栈内存。</li>
</ul>
<h3 id="2-2-存储机制"><a href="#2-2-存储机制" class="headerlink" title="2.2 存储机制"></a>2.2 存储机制</h3><ul>
<li>堆栈要求存放的数据的大小，生命周期必须是已经确定的。</li>
<li>堆可以被jvm动态的分配内存大小，无需事先告诉编译器的数据的大小、生命周期等相关信息。</li>
</ul>
<h4 id="1-栈内存和堆内存的存储数据类型为何不同？"><a href="#1-栈内存和堆内存的存储数据类型为何不同？" class="headerlink" title="1. 栈内存和堆内存的存储数据类型为何不同？"></a>1. 栈内存和堆内存的存储数据类型为何不同？</h4><p>我们知道在Java中，变量的类型通常分为：基本数据类型变量和对象引用变量。<br>首先，8种基本数据类型中的数字类型实际上都是存储的一组位数(所占bit位)不同的二进制数据；除此之外，布尔型只有true和false两种可能值。<br>其次，对象引用变量存储的，实际是其所关联(指向)对象在内存中的内存地址，而内存地址实际上也是一串二进制的数据。<br>所以，局部变量的大小是可以被确定的；<br>接下来，java中，局部变量会在其自身所属方法（或代码块）执行完毕后，被自动释放。<br>所以局部变量的生命周期也是可以被确定的。<br>那么，既然局部变量的大小和生命周期都可以被确定，完全符合栈内存的存储特点。自然，局部变量被存放在栈内存中。</p>
<p>而Java中使用关键字new通过调用类的构造函数，从而得到该类的对象。<br>对象类型数据在程序编译期，并不会在内存中进行创建和存储工作；而是在程序运行期，才根据需要进行动态的创建和存储。<br>也就是说，在程序运行之前，我们永远不能确定这个对象的内容、大小、生命周期。自然，对象由堆内存进行存储管理。</p>
<h4 id="2-为什么栈内存的速度高于堆内存？"><a href="#2-为什么栈内存的速度高于堆内存？" class="headerlink" title="2. 为什么栈内存的速度高于堆内存？"></a>2. 为什么栈内存的速度高于堆内存？</h4><ol>
<li><p>栈中数据大小和生命周期确定；堆中不确定。</p>
</li>
<li><p>说到大小，栈中存放的局部变量（8种基本数据类型和对象引用）实际值基本都是一串二进制数据，所以数据很小。而堆中存放的对象类型数据更大。</p>
</li>
<li><p>说到生命周期，栈中的数据在其所属方法或代码块执行结束后，就被释放；而堆中的数据由垃圾回收机制进行管理，无法确定合适会被回收释放。</p>
</li>
</ol>
<p>那么，一进行比较，很明显的可以预见到：自身信息（大小和生命周期）确定，数据大小更小的数据被处理起来肯定更加快捷，所以栈的存储管理速度优于堆。</p>
<h4 id="3-为什么堆内存的灵活性高于栈内存？"><a href="#3-为什么堆内存的灵活性高于栈内存？" class="headerlink" title="3. 为什么堆内存的灵活性高于栈内存？"></a>3. 为什么堆内存的灵活性高于栈内存？</h4><p>这就更好理解了，一个要求数据的大小、生命周期都必须被确定。一个可以动态的分配内存大小，也不必事先了解存储数据的任何信息。<br>何为灵活性？也就是我们可以有更多的变数。那么对应的，规则越多，限制则越强，灵活性也就越弱。所以堆内存的灵活性自然高于栈内存。</p>
<h2 id="3-数据共享"><a href="#3-数据共享" class="headerlink" title="3.数据共享"></a>3.数据共享</h2><p>栈和常量池都有一个特点就是共享数据。</p>
<p>假设我们同时定义了两个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>; </span><br><span class="line"><span class="keyword">int</span> b = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>这时候编译器的工作过程是：首先会在栈中开辟一块名为”a“的存储空间，然后查看栈中是否存放着一个”100“的值，发现在栈中没有找到这样的一个值，那么向栈中加入一个”100“的值，让”a“等于这个值。继而再在栈中开辟一块名为”b“的存储空间，这时候栈中已经存在一个”100“的值，那么就直接让”b“也等于这个值就行了。<br>由此我们发现，在完成对“a”的存储分配后，再存储“b”时，我们并没有再次向柜子放进一个“100”，而是直接将前一次放进栈中的“100”的地址拿给“b”，栈里面”100“这个值同时功共享给了变量”a“和”b“，这就是栈内存中的数据共享。那么，你可能会想，实现数据共享的好处是什么？自然是节约内存空间，既然同样的值可以实现共享，那么就避免了反复向内存中加入同样的值。<br>定义完a与b的值后，再令a = 4；那么，b不会等于4，还是等于100。在编译器内部，遇到时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。</p>
<p>那么，接下再看另一个例子(String类型的存储是相对比较特殊的)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.print(s1= =s2);</span><br></pre></td></tr></table></figure>
<p>这里的打印结果会是什么？我们可能会这样思考：<br>因为String是对象类型，定义了s1和s2两个对象引用，分别指向值同样为”abc“的两个String类型对象。<br>Java中，”==”用于比较两个对象引用时，实际是在比较这两个引用是否指向同一个对象。<br>所以这里应该会打印false。但事实上，打印的结果为true。这是由于什么原因造成的？</p>
<p>要搞清楚这个过程，首先要理解：</p>
<blockquote>
<p>String s = “abc”和String s = new String(“abc”)  </p>
</blockquote>
<p>两张声明方式的不同之处：<br>如果是使用String s = “abc”这种形式，也就是直接用双引号定义的形式。<br>可以看做我们声明了一个值为”abc“的字符串对象引用变量s。<br>但是，由于String类是final的，所以事实上，可以看做是声明了一个字符串引用常量。存放在常量池中。<br>如果是使用关键字new这种形式声明出的，则是在程序运行期被动态创建，存放在堆中。</p>
<p>所以，对于字符串而言，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中；<br>如果是运行期（new出来的）才能确定的就存储在堆中。<br>对于equals相等的字符串，在常量池中永远只有一份，在堆中可以有多份。</p>
<p>了解了字符串存储的这种特点，就可以对上面两种不同的声明方式进一步细化理解：</p>
<blockquote>
<p>String s = ”abc“<br>的工作过程可以分为以下几个步骤：</p>
</blockquote>
<p>(1)定义了一个名为”s”的String类型的引用。</p>
<p>(2)检查在常量池中是否存在值为”abc”的字符串对象；</p>
<p>(3)如果不存在，则在常量池（字符串池）创建存储进一个值为”abc”的字符串对象。如果已经存在，则跳过这一步工作。</p>
<p>(4)将对象引用s指向字符串池当中的”abc“对象。</p>
<blockquote>
<p>String s = new String(”abc“)<br>的步骤则为：</p>
</blockquote>
<p>(1)定义了一个名为”s”的String类型的引用。</p>
<p>(2)检查在常量池中是否存在值为”abc”的字符串对象；</p>
<p>(3)如果不存在，则在常量池（字符串池）存储进一个值为”abc”的字符串对象。如果已经存在，则跳过这一步工作。</p>
<p>(4)在堆中创建存储一个”abc“字符串对象。</p>
<p>(5)将对象引用指向堆中的对象。</p>
<p>这里指的注意的是，采用new的方式，虽然是在堆中存储对象，但是也会在存储之前检查常量池中是否已经含有此对象，如果没有，则会先在常量池创建对象，然后在堆中创建这个对象的”拷贝对象“。这也就是为什么有道面试题：</p>
<blockquote>
<p>String s = new String(“xyz”);   </p>
</blockquote>
<p>产生几个对象？的答案是：一个或两个的原因。因为如果常量池中原来没有”xyz”,就是两个。</p>
<p>弄清楚了原理，再看上面的例子，就知道为什么了。在执行String s1 = ‘abc”时;常量池中还没有对象，所以创建一个对象。之后在执行String s2 = ‘abc”的时候，因为常量池中已经存在了”abc’对象，所以说s2只需要指向这个对象就完成工作了。那么s1和s2指向同一个对象,用”==“比较自然返回true。所以常量池与栈内存一样，也可以实现数据共享。</p>
<p>还有值得注意的一点的就是：我们知道局部变量存储于栈内存当中。<br>那么成员变量呢？答案是：<em>成员变量的数据存储于堆中该成员变量所属的对象里面</em>。</p>
<p>而栈内存与堆内存的另一不同点在于，堆内存中存放的变量都会进行默认初始化，而栈内存中存放的变量却不会。<br>这也就是为什么，我们在声明一个成员变量时，可以不用对其进行初始化赋值。而如果声明一个局部变量却未进行初始赋值，如果想对其进行使用就会报编译异常的原因了。</p>
<hr>
<h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BirthDate</span> </span>&#123;    </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> day;    </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> month;    </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> year;        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">BirthDate</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> y)</span> </span>&#123;    </span><br><span class="line">           day = d;     </span><br><span class="line">           month = m;     </span><br><span class="line">           year = y;    </span><br><span class="line">       &#125;    </span><br><span class="line">       省略get,set方法………    </span><br><span class="line">   &#125;    </span><br><span class="line">       </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;    </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;    </span><br><span class="line">            <span class="keyword">int</span> date = <span class="number">9</span>;    </span><br><span class="line">            Test test = <span class="keyword">new</span> Test();          </span><br><span class="line">            test.change(date);     </span><br><span class="line">            BirthDate d1= <span class="keyword">new</span> BirthDate(<span class="number">7</span>,<span class="number">7</span>,<span class="number">1970</span>);           </span><br><span class="line">       &#125;      </span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;    </span><br><span class="line">           i = <span class="number">1234</span>;    </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><img src="java-memory/java_memory.png" alt=""></p>
<p>对于以上这段代码，date为局部变量，i,d,m,y都是形参为局部变量，day，month，year为成员变量。下面分析一下代码执行时候的变化：</p>
<p>main方法开始执行：int date = 9;<br>date局部变量，基础类型，引用和值都存在栈中。<br>Test test = new Test();<br>test为对象引用，存在栈中，对象(new Test())存在堆中。<br>test.change(date);<br>调用change(int i)方法，i为局部变量，引用和值存在栈中。当方法change执行完成后，i就会从栈中消失。<br>BirthDate d1= new BirthDate(7,7,1970);<br>调用BIrthDate类的构造函数生成对象。<br>d1为对象引用，存在栈中；<br>对象(new BirthDate())存在堆中；<br>其中d,m,y为局部变量存储在栈中，且它们的类型为基础类型，因此它们的数据也存储在栈中；<br>day,month,year为BirthDate对象的的成员变量，它们存储在堆中存储的new BirthDate()对象里面；<br>当BirthDate构造方法执行完之后，d,m,y将从栈中消失。<br>main方法执行完之后。<br>date变量，test，d1引用将从栈中消失；<br>new Test(),new BirthDate()将等待垃圾回收器进行回收。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown学习</title>
    <url>/2020/04/04/markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>Markdown 是一种轻量级标记语言，具有纯文本格式语法。</p>
</blockquote>
<p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。<br>用于编写说明文档，并且以“README.md”的文件名保存在软件的目录下面。<br>除此之外，由于我们有了RStudio这样的神级编辑器，我们还可以快速将Markdown转化为演讲PPT、Word产品文档、LaTex论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown已经广泛使用，极大地推进了动态可重复性研究的历史进程。</p>
<p>相信我；一旦你学会使用 Markdown，每一项写作任务在某种程度上都会比以前更容易、更好。让我们开始吧。<a id="more"></a></p>
<h2 id="标题使用"><a href="#标题使用" class="headerlink" title="标题使用"></a>标题使用</h2><h3 id="标题有两种表现方式"><a href="#标题有两种表现方式" class="headerlink" title="标题有两种表现方式"></a>标题有两种表现方式</h3><h3 id="1-使用‘-’和‘-’分别表示一级和二级标题（只能表示两种标题）"><a href="#1-使用‘-’和‘-’分别表示一级和二级标题（只能表示两种标题）" class="headerlink" title="1.使用‘=’和‘-’分别表示一级和二级标题（只能表示两种标题）"></a>1.使用‘=’和‘-’分别表示一级和二级标题（只能表示两种标题）</h3><p>例如：</p>
<p> 一级标题</p>
<p> =======</p>
<p> 二级标题</p>
<p>------</p>
<hr>
<h3 id="2-使用‘-’表示1-6级标题，‘-’个数即代表几级标题"><a href="#2-使用‘-’表示1-6级标题，‘-’个数即代表几级标题" class="headerlink" title="2.使用‘#’表示1-6级标题，‘#’个数即代表几级标题"></a>2.使用‘#’表示1-6级标题，‘#’个数即代表几级标题</h3><p>例如：</p>
<p> # 一级标题</p>
<p> ## 二级标题</p>
<p> ### 三级标题</p>
<p> #### 四级标题</p>
<hr>
<h2 id="段落格式使用"><a href="#段落格式使用" class="headerlink" title="段落格式使用"></a>段落格式使用</h2><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>段落换行使用两个空格加上回车即可，也可以在短落后增加一个空行实现换行</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>字体有斜体，粗体等  </p>
<p>*斜体文本*</p>
<p>_斜体文本_</p>
<p>**粗体文本**</p>
<p>__粗体文本__</p>
<p>***粗斜体文本***</p>
<p>___粗斜体文本___</p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。每种写法都可以建立分隔线：</p>
<p>***</p>
<p>* * *</p>
<p>******</p>
<p>- - -</p>
<p>---------</p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果文字上需要增加删除线，只需在文字两端各添加两个波浪线即可</p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>文本[^脚注]</p>
<p>[^脚注]：hello world</p>
<hr>
<h2 id="列表使用"><a href="#列表使用" class="headerlink" title="列表使用"></a>列表使用</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用 * ，+ ，- 来标记</p>
<p>* 第一项</p>
<p>* 第二项</p>
<p>+ 第一项</p>
<p>+ 第二项</p>
<p>- 第一项</p>
<p>-第二项</p>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字并加上 . 号来表示</p>
<ol>
<li><p>第一项</p>
</li>
<li><p>第二项</p>
</li>
</ol>
<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套需在<strong>子列表</strong>的选项添加<strong>4</strong>个空格即可</p>
<hr>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块引用在段落开头使用 ‘&gt;’ 符号，然后后面紧跟一个<strong>空格</strong>符号</p>
<p>区块是可以嵌套的，一个 ‘&gt;’ 符号是最外层，两个 ‘&gt;’ 符号是第一层嵌套，以此类推</p>
<p>&gt; 最外层</p>
<p>&gt; &gt; 第一层嵌套</p>
<p>&gt; &gt; &gt; 第二层嵌套</p>
<p>区块中使用列表</p>
<p>&gt; 区块中使用列表</p>
<p>&gt; 1. 第一项</p>
<p>&gt; 2. 第二项</p>
<p>&gt; + 第一项</p>
<p>&gt; + 第二项</p>
<p>&gt; + 第三项</p>
<p>列表中使用区块</p>
<p>* 第一项<br>    &gt; hello<br>    &gt; world<br>* 第二项</p>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p>
<blockquote>
<p>`print()`函数</p>
</blockquote>
<p>代码区块使用4个空格符号或者一个tab键，也可使用```包裹一段代码，并指定一种语言（也可以不指定）</p>
<pre><code>public static void main(String[] args){      
  Systemr.out.print(&quot;haha&quot;);  
};</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  	</span><br><span class="line">  System.out.print(<span class="string">"haha"</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>使用方法如下</p>
<p>[链接名称](链接地址) 或者 &lt;链接地址&gt;</p>
<p>这是一个链接 [test](<a href="https://www.test.com" target="_blank" rel="noopener">https://www.test.com</a> )</p>
<p>&lt; <a href="https://www.runoob.com" target="_blank" rel="noopener">https://www.runoob.com</a> &gt;</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="markdown%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E7%89%87.png" alt=""></p>
<p><img src="markdown%E5%AD%A6%E4%B9%A0/img%E6%A0%87%E7%AD%BE.png" alt=""></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p>
<p>|  表头   | 表头  |<br>|  —-  | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |</p>
<h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><p>我们可以设置表格的对齐方式：</p>
<p>-: 设置内容和标题栏居右对齐。</p>
<p>:- 设置内容和标题栏居左对齐。</p>
<p>:-: 设置内容和标题栏居中对齐。</p>
<p><img src="markdown%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E9%BD%90.png" alt=""></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
