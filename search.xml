<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>每日一条linux命令之lsof命令</title>
    <url>/2020/05/26/linux-24/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规</p>
<p>数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件</p>
<p>描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供</p>
<p>了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>lsof [参数] [文件]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为 lsof 需要访问核心内存和各种文件，所以需要root用户执行。</p>
<p>lsof打开的文件可以是：</p>
<p>1.普通文件</p>
<p>2.目录</p>
<p>3.网络文件系统的文件</p>
<p>4.字符或设备文件</p>
<p>5.(函数)共享库</p>
<p>6.管道，命名管道</p>
<p>7.符号链接</p>
<p>8.网络文件（例如：NFS file、网络socket，unix域名socket）</p>
<p>9.还有其它类型的文件。。。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-a 列出打开文件存在的进程</p>
<p>-c&lt;进程名&gt; 列出指定进程所打开的文件</p>
<p>-g  列出GID号进程详情</p>
<p>-d&lt;文件号&gt; 列出占用该文件号的进程</p>
<p>+d&lt;目录&gt;  列出目录下被打开的文件</p>
<p>+D&lt;目录&gt;  递归列出目录下被打开的文件</p>
<p>-n&lt;目录&gt;  列出使用NFS的文件</p>
<p>-i&lt;条件&gt;  列出符合条件的进程。（4、6、协议、:端口、 @ip ）</p>
<p>-p&lt;进程号&gt; 列出指定进程号所打开的文件</p>
<p>-u  列出UID号进程详情</p>
<p>-h 显示帮助信息</p>
<p>-v 显示版本信息</p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>lsof输出各列信息的意义如下：</p>
<p>COMMAND：进程的名称</p>
<p>PID：进程标识符</p>
<p>PPID：父进程标识符（需要指定-R参数）</p>
<p>USER：进程所有者</p>
<p>PGID：进程所属组</p>
<p>FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等</p>
<p>（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</p>
<p>（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序</p>
<p>（3）lnn：library references (AIX);</p>
<p>（4）er：FD information error (see NAME column);</p>
<p>（5）jld：jail directory (FreeBSD);</p>
<p>（6）ltx：shared library text (code and data);</p>
<p>（7）mxx ：hex memory-mapped type number xx.</p>
<p>（8）m86：DOS Merge mapped file;</p>
<p>（9）mem：memory-mapped file;</p>
<p>（10）mmap：memory-mapped device;</p>
<p>（11）pd：parent directory;</p>
<p>（12）rtd：root directory;</p>
<p>（13）tr：kernel trace file (OpenBSD);</p>
<p>（14）v86  VP/ix mapped file;</p>
<p>（15）0：表示标准输出</p>
<p>（16）1：表示标准输入</p>
<p>（17）2：表示标准错误</p>
<p>一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等</p>
<p>（1）u：表示该文件被打开并处于读取/写入模式</p>
<p>（2）r：表示该文件被打开并处于只读模式</p>
<p>（3）w：表示该文件被打开并处于</p>
<p>（4）空格：表示该文件的状态模式为unknow，且没有锁定</p>
<p>（5）-：表示该文件的状态模式为unknow，且被锁定</p>
<p>同时在文件状态模式后面，还跟着相关的锁</p>
<p>（1）N：for a Solaris NFS lock of unknown type;</p>
<p>（2）r：for read lock on part of the file;</p>
<p>（3）R：for a read lock on the entire file;</p>
<p>（4）w：for a write lock on part of the file;（文件的部分写锁）</p>
<p>（5）W：for a write lock on the entire file;（整个文件的写锁）</p>
<p>（6）u：for a read and write lock of any length;</p>
<p>（7）U：for a lock of unknown type;</p>
<p>（8）x：for an SCO OpenServer Xenix lock on part      of the file;</p>
<p>（9）X：for an SCO OpenServer Xenix lock on the      entire file;</p>
<p>（10）space：if there is no lock.</p>
<p>TYPE：文件类型，如DIR、REG等，常见的文件类型</p>
<p>（1）DIR：表示目录</p>
<p>（2）CHR：表示字符类型</p>
<p>（3）BLK：块设备类型</p>
<p>（4）UNIX： UNIX 域套接字</p>
<p>（5）FIFO：先进先出 (FIFO) 队列</p>
<p>（6）IPv4：网际协议 (IP) 套接字</p>
<p>DEVICE：指定磁盘的名称</p>
<p>SIZE：文件的大小</p>
<p>NODE：索引节点（文件在磁盘上的标识）</p>
<p>NAME：打开文件的确切名称</p>
<p>实例1：通过某个进程号显示该进行打开的文件</p>
<p>命令：</p>
<p>lsof -p 1</p>
<p>实例2：列出多个进程号对应的文件信息</p>
<p>命令：</p>
<p>lsof -p 1,2,3</p>
<p>实例3：列出除了某个进程号，其他进程号所打开的文件信息</p>
<p>命令：</p>
<p>lsof -p ^1</p>
<p>实例4：列出所有的网络连接</p>
<p>命令：</p>
<p>lsof -i</p>
<p>实例5：列出所有tcp 网络连接信息</p>
<p>命令：</p>
<p>lsof -i tcp</p>
<p>实例6：列出所有udp网络连接信息</p>
<p>命令：</p>
<p>lsof -i udp</p>
<p>实例7：列出谁在使用某个端口</p>
<p>命令：</p>
<p>lsof -i :3306</p>
<p>实例8：列出谁在使用某个特定的udp端口</p>
<p>命令：</p>
<p>lsof -i udp:55</p>
<p>或者：特定的tcp端口</p>
<p>命令：</p>
<p>lsof -i tcp:80</p>
<p>实例9：列出某个用户的所有活跃的网络端口</p>
<p>命令：</p>
<p>lsof -a -u test -i</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之free命令</title>
    <url>/2020/05/15/linux-23/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>free命令可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。在Linux系统监控的工具中，free命令是最经常使</p>
<p>用的命令之一。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>free [参数]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-b 　以Byte为单位显示内存使用情况。 </p>
<p>-k 　以KB为单位显示内存使用情况。 </p>
<p>-m 　以MB为单位显示内存使用情况。</p>
<p>-g   以GB为单位显示内存使用情况。 </p>
<p>-o 　不显示缓冲区调节列。 </p>
<p>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 </p>
<p>-t 　显示内存总和列。 </p>
<p>-V 　显示版本信息。 </p>
<p>字段解释</p>
<p>total:总计物理内存的大小。</p>
<p>used:已使用多大。</p>
<p>free:可用有多少。</p>
<p>Shared:多个进程共享的内存总额。</p>
<p>Buffers/cached:磁盘缓存的大小。</p>
<p>第三行(-/+ buffers/cached):</p>
<p>used:已使用多大。</p>
<p>free:可用有多少。</p>
<p>第四行是交换分区SWAP的，也就是我们通常所说的虚拟内存。</p>
<p>区别：第二行(mem)的used/free与第三行(-/+ buffers/cache) used/free的区别。 这两个的区别在于使用的角度来看，第一行是从OS的角度来看，因为对于OS，buffers/cached 都是属于被使用，所以他的可用内存是2098428KB,已用内存是30841684KB,其中包括，内核（OS）使用+Application(X, oracle,etc)使用的+buffers+cached.</p>
<p>第三行所指的是从应用程序角度来看，对于应用程序来说，buffers/cached 是等于可用的，因为buffer/cached是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer/cached会很快地被回收。</p>
<p>所以从应用程序的角度来说，可用内存=系统free memory+buffers+cached。</p>
<p>那buffers和cached都是缓存，两者有什么区别呢？</p>
<p>为了提高磁盘存取效率, Linux做了一些精心的设计, 除了对dentry进行缓存(用于VFS,加速文件路径名到inode的转换), 还采取了两种主要Cache方式：Buffer Cache和Page Cache。前者针对磁盘块的读写，后者针对文件inode的读写。这些Cache有效缩短了 I/O系统调用(比如read,write,getdents)的时间。</p>
<p>磁盘的操作有逻辑级（文件系统）和物理级（磁盘块），这两种Cache就是分别缓存逻辑和物理级数据的。</p>
<p>Page cache实际上是针对文件系统的，是文件的缓存，在文件层面上的数据会缓存到page cache。文件的逻辑层需要映射到实际的物理磁盘，这种映射关系由文件系统来完成。当page cache的数据需要刷新时，page cache中的数据交给buffer cache，因为Buffer Cache就是缓存磁盘块的。但是这种处理在2.6版本的内核之后就变的很简单了，没有真正意义上的cache操作。</p>
<p>Buffer cache是针对磁盘块的缓存，也就是在没有文件系统的情况下，直接对磁盘进行操作的数据会缓存到buffer cache中，例如，文件系统的元数据都会缓存到buffer cache中。</p>
<p>简单说来，page cache用来缓存文件数据，buffer cache用来缓存磁盘数据。在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。</p>
<p>所以我们看linux,只要不用swap的交换空间,就不用担心自己的内存太少.如果常常swap用很多,可能你就要考虑加物理内存了.这也是linux看内存是否够用的标准.</p>
<p>如果是应用服务器的话，一般只看第二行，+buffers/cache,即对应用程序来说free的内存太少了，也是该考虑优化程序或加内存了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之top命令</title>
    <url>/2020/05/15/linux-22/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。<a id="more"></a></p>
<p>下面详细介绍它的使用方法。top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终</p>
<p>止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内</p>
<p>存</p>
<p>使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.</p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>top [参数]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-b 批处理</p>
<p>-c 显示完整的治命令</p>
<p>-I 忽略失效过程</p>
<p>-s 保密模式</p>
<p>-S 累积模式</p>
<p>-i&lt;时间&gt; 设置间隔时间</p>
<p>-u&lt;用户名&gt; 指定用户名</p>
<p>-p&lt;进程号&gt; 指定进程</p>
<p>-n&lt;次数&gt; 循环显示的次数</p>
<p>统计信息区：</p>
<p>前五行是当前系统情况整体的统计信息区。下面我们看每一行信息的具体意义。</p>
<p>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</p>
<p>14:06:23 — 当前系统时间</p>
<p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p>
<p>2 users — 当前有2个用户登录系统</p>
<p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
<p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p>
<p>第二行，Tasks — 任务（进程），具体信息说明如下：</p>
<p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<p>第三行，cpu状态信息，具体属性说明如下：</p>
<p>5.9%us — 用户空间占用CPU的百分比。</p>
<p>3.4% sy — 内核空间占用CPU的百分比。</p>
<p>0.0% ni — 改变过优先级的进程占用CPU的百分比</p>
<p>90.4% id — 空闲CPU百分比</p>
<p>0.0% wa — IO等待占用CPU的百分比</p>
<p>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</p>
<p>0.2% si — 软中断（Software Interrupts）占用CPU的百分比</p>
<p>备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p>
<p>第四行,内存状态，具体信息如下：</p>
<p>32949016k total — 物理内存总量（32GB）</p>
<p>14411180k used — 使用中的内存总量（14GB）</p>
<p>18537836k free — 空闲内存总量（18GB）</p>
<p>169884k buffers — 缓存的内存量 （169M）</p>
<p>第五行，swap交换分区信息，具体信息说明如下：</p>
<p>32764556k total — 交换区总量（32GB）</p>
<p>0k used — 使用的交换区总量（0K）</p>
<p>32764556k free — 空闲交换区总量（32GB）</p>
<p>3612636k cached — 缓冲的交换区总量（3.6GB）</p>
<p>备注：</p>
<p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</p>
<p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：18537836k +169884k +3612636k = 22GB左右。</p>
<p>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p>
<p>第六行，空行。</p>
<p>第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</p>
<p>PID — 进程id</p>
<p>USER — 进程所有者</p>
<p>PR — 进程优先级</p>
<p>NI — nice值。负值表示高优先级，正值表示低优先级</p>
<p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</p>
<p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</p>
<p>SHR — 共享内存大小，单位kb</p>
<p>S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</p>
<p>%CPU — 上次更新到现在的CPU时间占用百分比</p>
<p>%MEM — 进程使用的物理内存百分比</p>
<p>TIME+ — 进程使用的CPU时间总计，单位1/100秒</p>
<p>COMMAND — 进程名称（命令名/命令行）</p>
<p>其他使用技巧：</p>
<p>1.多U多核CPU监控</p>
<p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况：</p>
<p>观察上图，服务器有16个逻辑CPU，实际上是4个物理CPU。再按数字键1，就会返回到top基本视图界面。</p>
<p>2.高亮显示当前运行进程</p>
<p>敲击键盘“b”（打开/关闭加亮效果），top的视图变化如下：</p>
<p>我们发现进程id为2570的“top”进程被加亮了，top进程就是视图第二行显示的唯一的运行态（runing）的那个进程，可以通过敲击“y”键关闭或打开运行态进程的加亮效果。</p>
<p>3.进程字段排序</p>
<p>默认进入top时，各进程是按照CPU的占用量来排序的，在下图中进程ID为28894的java进程排在第一（cpu占用142%），进程ID为574的java进程排在第二（cpu占用16%）。</p>
<p>敲击键盘“x”（打开/关闭排序列的加亮效果），top的视图变化如下：      </p>
<p>可以看到，top默认的排序列是“%CPU”。</p>
<p>4.通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之kill命令</title>
    <url>/2020/05/15/linux-21/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>kill命令用来终止指定的进程的运行，是Linux下进程管理的常用命令。<a id="more"></a></p>
<p>通常，终止一个前台进程可以使用Ctrl+C键</p>
<p>，但是，对于一个后台进程就须用kill命令来终止，我们就需要先使用ps/pidof/pstree/top等工具获取进程PID，然后使用kill命令来杀掉该</p>
<p>进程。kill命令是通过向进程发送指定的信号来结束相应进程的。在默认情况下，采用编号为15的TERM信号。TERM信号将终止所有不能捕获该信号</p>
<p>的进程。对于那些可以捕获该信号的进程就要用编号为9的kill信号，强行“杀掉”该进程。</p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>kill [参数] [进程号]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用“-KILL”</p>
<p>参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs</p>
<p>命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</p>
<p>-a  当处理当前进程时，不限制命令名和进程号的对应关系</p>
<p>-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号</p>
<p>-s  指定发送信号</p>
<p>-u  指定用户 </p>
<p>注意：</p>
<p>1、kill命令可以带信号号码选项，也可以不带。如果没有信号号码，kill命令就会发出终止信号(15)，这个信号可以被进程捕获，使得进程在退出之前可以清理并释放资源。也可以用kill向进程发送特定的信号。例如：</p>
<p>kill -2 123</p>
<p>它的效果等同于在前台运行PID为123的进程时按下Ctrl+C键。但是，普通用户只能使用不带signal参数的kill命令或最多使用-9信号。</p>
<p>2、kill可以带有进程ID号作为参数。当用kill向这些进程发送信号时，必须是这些进程的主人。如果试图撤销一个没有权限撤销的进程或撤销一个不存在的进程，就会得到一个错误信息。</p>
<p>3、可以向多个进程发信号或终止它们。</p>
<p>4、当kill成功地发送了信号后，shell会在屏幕上显示出进程的终止信息。有时这个信息不会马上显示，只有当按下Enter键使shell的命令提示符再次出现时，才会显示出来。</p>
<p>5、应注意，信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法。</p>
<p>只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略。 下面是常用的信号：</p>
<p>HUP    1    终端断线</p>
<p>INT     2    中断（同 Ctrl + C）</p>
<p>QUIT    3    退出（同 Ctrl + \）</p>
<p>TERM   15    终止</p>
<p>KILL    9    强制终止</p>
<p>CONT   18    继续（与STOP相反， fg/bg命令）</p>
<p>STOP    19    暂停（同 Ctrl + Z）</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之ps命令</title>
    <url>/2020/05/15/linux-20/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ps命令用来列出系统当前所有运行的进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程</p>
<p>信息，就可以使用top命令。<a id="more"></a></p>
<p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。</p>
<p>使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可</p>
<p>以通过执行该命令得到的。</p>
<p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。</p>
<p>kill 命令用于杀死进程。</p>
<p>linux上进程有5种状态: </p>
<ol>
<li><p>运行(正在运行或在运行队列中等待) </p>
</li>
<li><p>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) </p>
</li>
<li><p>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) </p>
</li>
<li><p>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) </p>
</li>
<li><p>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) </p>
</li>
</ol>
<p>ps工具标识进程的5种状态码: </p>
<p>D 不可中断 uninterruptible sleep (usually IO) </p>
<p>R 运行 runnable (on run queue) </p>
<p>S 中断 sleeping </p>
<p>T 停止 traced or stopped </p>
<p>Z 僵死 a defunct (”zombie”) process </p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>ps [参数] </p>
<p>ps 与 grep 常用组合用法，查找特定进程</p>
<p>ps -ef|grep ssh</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>显示当前进程状态</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>a  显示所有进程</p>
<p>-a 显示同一终端下的所有程序</p>
<p>-A 显示所有进程</p>
<p>c  显示进程的真实名称</p>
<p>-N 反向选择</p>
<p>-e 等于“-A”</p>
<p>e  显示环境变量</p>
<p>f  显示程序间的关系</p>
<p>-H 显示树状结构</p>
<p>r  显示当前终端的进程</p>
<p>T  显示当前终端的所有程序</p>
<p>u  指定用户的所有进程</p>
<p>-au 显示较详细的资讯</p>
<p>-aux 显示所有包含其他使用者的行程 </p>
<p>-C&lt;命令&gt; 列出指定命令的状况</p>
<p>–lines&lt;行数&gt; 每页显示的行数</p>
<p>–width&lt;字符数&gt; 每页显示的字符数</p>
<p>–help 显示帮助信息</p>
<p>–version 显示版本显示</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之find命令</title>
    <url>/2020/05/09/linux-19/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Linux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件</p>
<p>，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一</p>
<p>下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运</p>
<p>行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花</p>
<p>费很长的时间(这里是指30G字节以上的文件系统)。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>find pathname -options [-print -exec -ok …]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>用于在文件树种查找文件，并作出相应的处理 </p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 </p>
<p>-print： find命令将匹配的文件输出到标准输出。 </p>
<p>-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {  }</p>
<p> ;，注意{   }和\；之间的空格。 </p>
<p>-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个</p>
<p>命令之前，都会给出提示，让用户来确定是否执行。</p>
<h4 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h4><p>-name   按照文件名查找文件。</p>
<p>-perm   按照文件权限来查找文件。</p>
<p>-prune  使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。</p>
<p>-user   按照文件属主来查找文件。</p>
<p>-group  按照文件所属的组来查找文件。</p>
<p>-mtime -n +n  按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。</p>
<p>-nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。</p>
<p>-nouser   查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。</p>
<p>-newer file1 ! file2  查找更改时间比文件file1新但比文件file2旧的文件。</p>
<p>-type  查找某一类型的文件，诸如：</p>
<p>b - 块设备文件。</p>
<p>d - 目录。</p>
<p>c - 字符设备文件。</p>
<p>p - 管道文件。</p>
<p>l - 符号链接文件。</p>
<p>f - 普通文件。</p>
<p>-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先<br>查找当前目录中的文件，然后再在其子目录中查找。</p>
<p>-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。</p>
<p>-mount：在查找文件时不跨越文件系统mount点。</p>
<p>-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。</p>
<p>-cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。</p>
<p>另外,下面三个的区别:</p>
<p>-amin n   查找系统中最后N分钟访问的文件</p>
<p>-atime n  查找系统中最后n*24小时访问的文件</p>
<p>-cmin n   查找系统中最后N分钟被改变文件状态的文件</p>
<p>-ctime n  查找系统中最后n*24小时被改变文件状态的文件</p>
<p>-mmin n   查找系统中最后N分钟被改变文件数据的文件</p>
<p>-mtime n  查找系统中最后n*24小时被改变文件数据的文件</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之locate命令</title>
    <url>/2020/05/08/linux-18/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，</p>
<p>之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在</p>
<p>crontab 中自动执行。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>Locate [选择参数] [样式]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，</p>
<p>locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或</p>
<p>刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)</p>
<p>locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特</p>
<p>殊字元（如”<em>” 或”?”等）来指定范本样式，如指定范本为kcpa</em>ner, </p>
<p>locate会找出所有起始字串为kcpa且结尾为ner的档案或目录，如名称为kcpartner若目录录名称为kcpa_</p>
<p>ner则会列出该目录下包括 子目录在内的所有档案。</p>
<p>locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在</p>
<p>执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索</p>
<p>引数据库。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-e   将排除在寻找的范围之外。</p>
<p>-1  如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate</p>
<p>必须至实际的档案系统中取得档案的 权限资料。</p>
<p>-f   将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。</p>
<p>-q  安静模式，不会显示任何错误讯息。</p>
<p>-n 至多显示 n个输出。</p>
<p>-r 使用正规运算式 做寻找的条件。</p>
<p>-o 指定资料库存的名称。</p>
<p>-d 指定资料库的路径</p>
<p>-h 显示辅助讯息</p>
<p>-V 显示程式的版本讯息</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之whereis命令</title>
    <url>/2020/05/07/linux-17/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码</p>
<p>文件（参数-s）。如果省略参数，则返回所有信息。</p>
<p>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库</p>
<p>文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通</p>
<p>过遍历硬盘来查找，效率自然会很高。 </p>
<p>但是该数据库文件并不是实时更新，默认情况下是一星期更新一次，因此，我们在用whereis和locate 查找</p>
<p>文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被</p>
<p>更新。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>whereis [-bmsu] [BMS 目录名 -f ] 文件名</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代</p>
<p>码，二进制文件，或是帮助文件。whereis程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-b   定位可执行文件。</p>
<p>-m   定位帮助文件。</p>
<p>-s   定位源代码文件。</p>
<p>-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</p>
<p>-B   指定搜索可执行文件的路径。</p>
<p>-M   指定搜索帮助文件的路径。</p>
<p>-S   指定搜索源代码文件的路径。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之which命令</title>
    <url>/2020/05/06/linux-16/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： </p>
<p>which  查看可执行文件的位置。</p>
<p>whereis 查看文件的位置。 </p>
<p>locate   配合数据库查看文件位置。</p>
<p>find   实际搜寻硬盘查询文件名称。</p>
<p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。<a id="more"></a> </p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>which 可执行文件名称 </p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</p>
<p>-p 　与-n参数相同，但此处的包括了文件的路径。</p>
<p>-w 　指定输出时栏位的宽度。</p>
<p>-V 　显示版本信息</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之tail命令</title>
    <url>/2020/05/05/linux-15/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,</p>
<p>tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. <a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>tail [必要参数] [选择参数] [文件]   </p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-f 循环读取</p>
<p>-q 不显示处理信息</p>
<p>-v 显示详细的处理信息</p>
<p>-c&lt;数目&gt; 显示的字节数</p>
<p>-n&lt;行数&gt; 显示行数</p>
<p>–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. </p>
<p>-q, –quiet, –silent 从不输出给出文件名的首部 </p>
<p>-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之head命令</title>
    <url>/2020/05/04/linux-14/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head</p>
<p>用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。 <a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>head [参数]… [文件]… </p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-q 隐藏文件名</p>
<p>-v 显示文件名</p>
<p>-c&lt;字节&gt; 显示字节数</p>
<p>-n&lt;行数&gt; 显示的行数</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之less命令</title>
    <url>/2020/05/03/linux-13/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其</p>
<p>强大。less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻，</p>
<p>只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] </p>
<p>等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less </p>
<p>里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 <a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>less [参数]  文件 </p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-b &lt;缓冲区大小&gt; 设置缓冲区的大小</p>
<p>-e  当文件显示结束后，自动离开</p>
<p>-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件</p>
<p>-g  只标志最后搜索的关键词</p>
<p>-i  忽略搜索时的大小写</p>
<p>-m  显示类似more命令的百分比</p>
<p>-N  显示每行的行号</p>
<p>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</p>
<p>-Q  不使用警告音</p>
<p>-s  显示连续空行为一行</p>
<p>-S  行过长时间将超出部分舍弃</p>
<p>-x &lt;数字&gt; 将“tab”键显示为规定的数字空格</p>
<p>/字符串：向下搜索“字符串”的功能</p>
<p>?字符串：向上搜索“字符串”的功能</p>
<p>n：重复前一个搜索（与 / 或 ? 有关）</p>
<p>N：反向重复前一个搜索（与 / 或 ? 有关）</p>
<p>b  向后翻一页</p>
<p>d  向后翻半页</p>
<p>h  显示帮助界面</p>
<p>Q  退出less 命令</p>
<p>u  向前滚动半页</p>
<p>y  向前滚动一行</p>
<p>空格键 滚动一行</p>
<p>回车键 滚动一页</p>
<p>[pagedown]： 向下翻动一页</p>
<p>[pageup]：   向上翻动一页</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之more命令</title>
    <url>/2020/05/02/linux-12/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 </p>
<p>more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按</p>
<p>b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。</p>
<p>more命令从前向后读取文件，因此在启动时就加载整个文件。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file … ] </p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持</p>
<p>直接跳转行等功能。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>+n       从笫n行开始显示</p>
<p>-n       定义屏幕大小为n行</p>
<p>+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示  </p>
<p>-c       从顶部清屏，然后显示</p>
<p>-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</p>
<p>-l        忽略Ctrl+l（换页）字符</p>
<p>-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</p>
<p>-s       把连续的多个空行显示为一行</p>
<p>-u       把文件内容中的下画线去掉</p>
<p>Enter    向下n行，需要定义。默认为1行</p>
<p>Ctrl+F   向下滚动一屏</p>
<p>空格键  向下滚动一屏</p>
<p>Ctrl+B  返回上一屏</p>
<p>=       输出当前行的行号</p>
<p>：f     输出文件名和当前行的行号</p>
<p>V      调用vi编辑器</p>
<p>!命令   调用Shell，并执行命令 </p>
<p>q       退出more</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之nl命令</title>
    <url>/2020/05/01/linux-11/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与</p>
<p>cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>nl  [选项]… [文件]…</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。</p>
<p>在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 </p>
<p>输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl </p>
<p>命令在每个逻辑页开始的地方重新设置行号。</p>
<p>可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-b  ：指定行号指定的方式，主要有两种：</p>
<p>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；</p>
<p>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</p>
<p>-n  ：列出行号表示的方法，主要有三种：</p>
<p>-n ln ：行号在萤幕的最左方显示；</p>
<p>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；</p>
<p>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</p>
<p>-w  ：行号栏位的占用的位数。</p>
<p>-p 在逻辑定界符处不重新开始计算。 </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之touch命令</title>
    <url>/2020/04/30/linux-09/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在</p>
<p>的文件。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>touch [选项]… 文件…</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。 </p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-a   或–time=atime或–time=access或–time=use 　只更改存取时间。</p>
<p>-c   或–no-create 　不建立任何文档。</p>
<p>-d 　使用指定的日期时间，而非现在的时间。</p>
<p>-f 　此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。</p>
<p>-m   或–time=mtime或–time=modify 　只更改变动时间。</p>
<p>-r 　把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。</p>
<p>-t 　使用指定的日期时间，而非现在的时间。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之cat命令</title>
    <url>/2020/04/30/linux-10/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示</p>
<p>，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 <a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>cat [选项] [文件]…</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>1.一次显示整个文件:cat filename</p>
<p>2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.</p>
<p>3.将几个文件合并为一个文件:cat file1 file2 &gt; file</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-A, –show-all           等价于 -vET</p>
<p>-b, –number-nonblank    对非空输出行编号</p>
<p>-e                       等价于 -vE</p>
<p>-E, –show-ends          在每行结束处显示 $</p>
<p>-n, –number     对输出的所有行编号,由1开始对所有输出的行数编号</p>
<p>-s, –squeeze-blank  有连续两行以上的空白行，就代换为一行的空白行 </p>
<p>-t                       与 -vT 等价</p>
<p>-T, –show-tabs          将跳格字符显示为 ^I</p>
<p>-u                       (被忽略)</p>
<p>-v, –show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之cp命令</title>
    <url>/2020/04/29/linux-08/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>cp命令是用来复制文件或者目录，是linux中最常用的命令之一。 <a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>cp [选项]… [-T] 源 目的</p>
<p>cp [选项]… 源… 目录</p>
<p>cp [选项]… -t 目录 源…</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-a：此参数的效果和同时指定”-dpR”参数相同；</p>
<p>-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；</p>
<p>-f：强行复制文件或目录，不论目标文件或目录是否已存在；</p>
<p>-i：覆盖既有文件之前先询问用户；</p>
<p>-l：对源文件建立硬连接，而非复制文件；</p>
<p>-p：保留源文件或目录的属性；</p>
<p>-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；</p>
<p>-s：对源文件建立符号连接，而非复制文件；</p>
<p>-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；</p>
<p>-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；</p>
<p>-b：覆盖已存在的文件目标前将目标文件备份；</p>
<p>-v：详细显示命令执行的操作。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之mv命令</title>
    <url>/2020/04/28/linux-07/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>mv是move的缩写，可以用来移动文件或者给为文件改名。通常用来备份文件或者目录 <a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>mv [选项] 源文件或目录 目标文件或目录</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>根据第二个参数类型来决定，mv命令将文件重命名或将其移至一个新的目录中。</p>
<p>如果第二个参数是文件时，mv命令会完成重命名功能，此时，源文件只能有一个（也可以是源目录名），它将所</p>
<p>给的源文件或目录重命名为给定的目标文件名。</p>
<p>当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标</p>
<p>目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>-b 若需覆盖文件，则覆盖前先行备份。 </p>
<p>-f force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</p>
<p>-i 若目标文件 (destination) 已经存在时，就会询问是否覆盖！</p>
<p>-u 若目标文件已经存在，且 source 比较新，才会更新(update)</p>
<p>-t 即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之rmdir命令</title>
    <url>/2020/04/27/linux-06/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。</p>
<p>（注意，rm - r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。</p>
<a id="more"></a>

<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>rmdir [选项] 目录名</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>该命令从一个目录中删除一个或多个空目录项，删除某目录时也必须具有对父目录的写权限。 </p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>-p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种</p>
<p>原因保留部分路径，则系统在标准输出上显示相应的信息。 </p>
<p>-v –verbose  显示指令执行过程</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之rm</title>
    <url>/2020/04/26/linux-05/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>rm命令是linux删除文件和目录的命令。</p>
<p>该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。</p>
<p>对于链接文件，只是删除了链接，原有文件均保持不变。</p>
<p>rm是一个危险的命令，使用的时候要特别当心。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>rm [选项] 文件</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>删除一个目录中的一个或者多个文件或目录，如果没有使用 -r 选项，则不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>-f 忽略不存在的文件，从不给出提示</p>
<p>-i 进行交互式删除</p>
<p>-r 指示 rm 将参数中的列出的全部目录及其子目录递归地删除</p>
<p>-v 详细地显示操作的步骤</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之mkdir</title>
    <url>/2020/04/25/linux-04/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>mkdir命令用来创建指定名称的目录，要求创建目录的用户在当前的目录下具有写权限，并且指定的名称不能是已经存在的名称。 <a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>mkdir [选项] 名称</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。</p>
<p>要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。</p>
<p>并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。</p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>-m 设定权限模式，类似chmod </p>
<p>-p 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多级目录</p>
<p>-v 每次创建新目录都显示信息</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之pwd</title>
    <url>/2020/04/24/linux-03/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>pwd命令用来查看当前工作目录的完整路径。每当在终端进行操作时，你都会有一个当前工作目录。在不确定当前</p>
<p>位置时，就可以使用‘pwd’命令来判定当前目录在文件系统内的确切位置。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>pwd [选项]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>查看”当前工作目录“的完整路径</p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>一般情况下不需要任何参数</p>
<p>如果目录是链接时：</p>
<p>格式：pwd -P  显示出实际路径，而非使用连接（link）路径。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之cd</title>
    <url>/2020/04/23/linux-02/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>cd命令是linux最基本的命令，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。</p>
<p>所以，学习Linux 常用命令，首先就要学好 cd 命令的使用方法技巧。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>cd [目录名]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>切换目录</p>
<h4 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h4><p>进入系统根目录: cd /  或者  cd ../.. //</p>
<p>查看当前目录路径: pwd</p>
<p>返回上级目录: cd ..</p>
<p>进入当前用户的主目录: cd 或者 cd ~</p>
<p>跳转到指定目录: cd /opt/publish</p>
<p>返回进入此目录之前所在的目录: cd -</p>
<p>把上个命令的参数作为cd参数使用: cd !$</p>
<p>例: cp something /usr/local/xxx  —&gt;  cd !$  直接就进入了xxx目录。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一条linux命令之ls</title>
    <url>/2020/04/22/linux-01/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ls命令是linux最常用的命令，它是list的缩写，主要用来打印当前目录下的文件夹及文件清单，除此之外还可</p>
<p>以查看文件权限和文件的信息等等。<a id="more"></a></p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>ls [选项] [目录名]</p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>打印出目标目录下的所有的子目录及问件</p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>-a  列出目标目录下的所有文件夹和文件，包括.开头的隐藏文件</p>
<p>-A  同-a，但不列出隐藏文件</p>
<p>-g  类似 -l,但不列出所有者</p>
<p>-h  以容易理解的格式列出文件大小 (例如 1K 234M 2G)</p>
<p>–si 类似 -h,但文件大小取 1000 的次方而不是 1024</p>
<p>-H  使用命令列中的符号链接指示的真正目的地</p>
<p>-l  除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</p>
<p>-r  依相反次序排列</p>
<p>-R  同时列出所有子目录层</p>
<p>-t  以文件修ls改时间排序</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>java存储区域</title>
    <url>/2020/04/07/java-memory/</url>
    <content><![CDATA[<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">位置</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器</td>
<td align="center">处理器内部</td>
<td align="center">快，不能人为控制</td>
</tr>
<tr>
<td align="center">堆栈</td>
<td align="center">RAM</td>
<td align="center">有点快，常用于存储句柄，基本数据类型</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">RAM</td>
<td align="center">存放对象，灵活，存储分配和清理较耗费时间</td>
</tr>
<tr>
<td align="center">静态存储</td>
<td align="center">RAM的固定位置</td>
<td align="center">用static指定</td>
</tr>
<tr>
<td align="center">常数存储</td>
<td align="center">程序代码内部</td>
<td align="center">字符串常量和基本类型常量</td>
</tr>
<tr>
<td align="center">非RAM存储</td>
<td align="center">非RAM</td>
<td align="center">-</td>
</tr>
</tbody></table>
<a id="more"></a>

<hr>
<h2 id="1-几种存储位置"><a href="#1-几种存储位置" class="headerlink" title="1.几种存储位置"></a>1.几种存储位置</h2><h3 id="1-1-寄存器"><a href="#1-1-寄存器" class="headerlink" title="1.1 寄存器"></a>1.1 寄存器</h3><p>最快的存储区域，位于处理器内部，所以数量非常有限。它是由编译器来进行分配，我们对此没有控制权。</p>
<h3 id="1-2-堆栈"><a href="#1-2-堆栈" class="headerlink" title="1.2 堆栈"></a>1.2 堆栈</h3><p>位于RAM当中，通过堆栈指针可以从处理器获得直接支持。堆栈指针向下移动，则分配新的内存；向上移动，则释放那些内存。这种存储方式速度仅次于寄存器。（常用于存放对象引用和基本数据类型，而不用于存储对象）</p>
<h3 id="1-3-堆"><a href="#1-3-堆" class="headerlink" title="1.3 堆"></a>1.3 堆</h3><p>一种通用的内存池，也位于RAM当中。其中存放的数据由JVM自动进行管理。<br>堆相对于栈的好处来说：编译器不需要知道存储的数据在堆里存活多长。当需要一个对象时，使用new写一行代码，当执行这行代码时，会自动在堆里进行存储分配。同时，因为以上原因，用堆进行数据的存储分配和清理，需要花费更多的时间。（常用于存储对象）</p>
<h3 id="1-4-静态存储"><a href="#1-4-静态存储" class="headerlink" title="1.4 静态存储"></a>1.4 静态存储</h3><p>“静态”是指位于RAM内的固定位置，程序运行期间，该区域的数据将随时等候被调用。可以用<em>static</em>关键字来制定该数据是静态的。</p>
<h3 id="1-5-常数存储"><a href="#1-5-常数存储" class="headerlink" title="1.5 常数存储"></a>1.5 常数存储</h3><p>常量(字符串常量和基本类型常量)通常直接存储在程序代码内部（常量池）。这样做是安全的，因为它们的值在初始化时就已经被确定，并不会被改变。常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s = “java”这种申明方式。</p>
<h3 id="1-6-非RAM存储"><a href="#1-6-非RAM存储" class="headerlink" title="1.6 非RAM存储"></a>1.6 非RAM存储</h3><p>如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是：流对象和持久化对象。在流对象中，对象转化为字节流，通常被发送给另一台机器。在持久化对象中，对象被存放在磁盘上。因此，即使程序终止，它们仍可以保持自己的状态。</p>
<hr>
<h2 id="2-堆和堆栈的对比"><a href="#2-堆和堆栈的对比" class="headerlink" title="2.堆和堆栈的对比"></a>2.堆和堆栈的对比</h2><h3 id="2-1-相同点和不同点"><a href="#2-1-相同点和不同点" class="headerlink" title="2.1 相同点和不同点"></a>2.1 相同点和不同点</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><p>堆和堆栈都是位于RAM（内存）内的存储区域，java会自动地管理堆和堆栈，不能人为控制。</p>
<h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><ul>
<li>存储数据类型：栈内存中存放局部变量（基本数据类型和对象引用)，而堆内存用于存放对象（实体）。</li>
<li>存储速度：就存储速度而言，栈内存的存储分配与清理速度更快于堆，并且栈内存的存储速度仅次于直接位于处理器当中的寄存器。</li>
<li>灵活性：就灵活性而言，由于栈内存与堆内存存储机制的不同，堆内存灵活性更优于栈内存。</li>
</ul>
<h3 id="2-2-存储机制"><a href="#2-2-存储机制" class="headerlink" title="2.2 存储机制"></a>2.2 存储机制</h3><ul>
<li>堆栈要求存放的数据的大小，生命周期必须是已经确定的。</li>
<li>堆可以被jvm动态的分配内存大小，无需事先告诉编译器的数据的大小、生命周期等相关信息。</li>
</ul>
<h4 id="1-栈内存和堆内存的存储数据类型为何不同？"><a href="#1-栈内存和堆内存的存储数据类型为何不同？" class="headerlink" title="1. 栈内存和堆内存的存储数据类型为何不同？"></a>1. 栈内存和堆内存的存储数据类型为何不同？</h4><p>我们知道在Java中，变量的类型通常分为：基本数据类型变量和对象引用变量。<br>首先，8种基本数据类型中的数字类型实际上都是存储的一组位数(所占bit位)不同的二进制数据；除此之外，布尔型只有true和false两种可能值。<br>其次，对象引用变量存储的，实际是其所关联(指向)对象在内存中的内存地址，而内存地址实际上也是一串二进制的数据。<br>所以，局部变量的大小是可以被确定的；<br>接下来，java中，局部变量会在其自身所属方法（或代码块）执行完毕后，被自动释放。<br>所以局部变量的生命周期也是可以被确定的。<br>那么，既然局部变量的大小和生命周期都可以被确定，完全符合栈内存的存储特点。自然，局部变量被存放在栈内存中。</p>
<p>而Java中使用关键字new通过调用类的构造函数，从而得到该类的对象。<br>对象类型数据在程序编译期，并不会在内存中进行创建和存储工作；而是在程序运行期，才根据需要进行动态的创建和存储。<br>也就是说，在程序运行之前，我们永远不能确定这个对象的内容、大小、生命周期。自然，对象由堆内存进行存储管理。</p>
<h4 id="2-为什么栈内存的速度高于堆内存？"><a href="#2-为什么栈内存的速度高于堆内存？" class="headerlink" title="2. 为什么栈内存的速度高于堆内存？"></a>2. 为什么栈内存的速度高于堆内存？</h4><ol>
<li><p>栈中数据大小和生命周期确定；堆中不确定。</p>
</li>
<li><p>说到大小，栈中存放的局部变量（8种基本数据类型和对象引用）实际值基本都是一串二进制数据，所以数据很小。而堆中存放的对象类型数据更大。</p>
</li>
<li><p>说到生命周期，栈中的数据在其所属方法或代码块执行结束后，就被释放；而堆中的数据由垃圾回收机制进行管理，无法确定合适会被回收释放。</p>
</li>
</ol>
<p>那么，一进行比较，很明显的可以预见到：自身信息（大小和生命周期）确定，数据大小更小的数据被处理起来肯定更加快捷，所以栈的存储管理速度优于堆。</p>
<h4 id="3-为什么堆内存的灵活性高于栈内存？"><a href="#3-为什么堆内存的灵活性高于栈内存？" class="headerlink" title="3. 为什么堆内存的灵活性高于栈内存？"></a>3. 为什么堆内存的灵活性高于栈内存？</h4><p>这就更好理解了，一个要求数据的大小、生命周期都必须被确定。一个可以动态的分配内存大小，也不必事先了解存储数据的任何信息。<br>何为灵活性？也就是我们可以有更多的变数。那么对应的，规则越多，限制则越强，灵活性也就越弱。所以堆内存的灵活性自然高于栈内存。</p>
<h2 id="3-数据共享"><a href="#3-数据共享" class="headerlink" title="3.数据共享"></a>3.数据共享</h2><p>栈和常量池都有一个特点就是共享数据。</p>
<p>假设我们同时定义了两个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>; </span><br><span class="line"><span class="keyword">int</span> b = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>这时候编译器的工作过程是：首先会在栈中开辟一块名为”a“的存储空间，然后查看栈中是否存放着一个”100“的值，发现在栈中没有找到这样的一个值，那么向栈中加入一个”100“的值，让”a“等于这个值。继而再在栈中开辟一块名为”b“的存储空间，这时候栈中已经存在一个”100“的值，那么就直接让”b“也等于这个值就行了。<br>由此我们发现，在完成对“a”的存储分配后，再存储“b”时，我们并没有再次向柜子放进一个“100”，而是直接将前一次放进栈中的“100”的地址拿给“b”，栈里面”100“这个值同时功共享给了变量”a“和”b“，这就是栈内存中的数据共享。那么，你可能会想，实现数据共享的好处是什么？自然是节约内存空间，既然同样的值可以实现共享，那么就避免了反复向内存中加入同样的值。<br>定义完a与b的值后，再令a = 4；那么，b不会等于4，还是等于100。在编译器内部，遇到时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。</p>
<p>那么，接下再看另一个例子(String类型的存储是相对比较特殊的)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.print(s1= =s2);</span><br></pre></td></tr></table></figure>
<p>这里的打印结果会是什么？我们可能会这样思考：<br>因为String是对象类型，定义了s1和s2两个对象引用，分别指向值同样为”abc“的两个String类型对象。<br>Java中，”==”用于比较两个对象引用时，实际是在比较这两个引用是否指向同一个对象。<br>所以这里应该会打印false。但事实上，打印的结果为true。这是由于什么原因造成的？</p>
<p>要搞清楚这个过程，首先要理解：</p>
<blockquote>
<p>String s = “abc”和String s = new String(“abc”)  </p>
</blockquote>
<p>两张声明方式的不同之处：<br>如果是使用String s = “abc”这种形式，也就是直接用双引号定义的形式。<br>可以看做我们声明了一个值为”abc“的字符串对象引用变量s。<br>但是，由于String类是final的，所以事实上，可以看做是声明了一个字符串引用常量。存放在常量池中。<br>如果是使用关键字new这种形式声明出的，则是在程序运行期被动态创建，存放在堆中。</p>
<p>所以，对于字符串而言，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中；<br>如果是运行期（new出来的）才能确定的就存储在堆中。<br>对于equals相等的字符串，在常量池中永远只有一份，在堆中可以有多份。</p>
<p>了解了字符串存储的这种特点，就可以对上面两种不同的声明方式进一步细化理解：</p>
<blockquote>
<p>String s = ”abc“<br>的工作过程可以分为以下几个步骤：</p>
</blockquote>
<p>(1)定义了一个名为”s”的String类型的引用。</p>
<p>(2)检查在常量池中是否存在值为”abc”的字符串对象；</p>
<p>(3)如果不存在，则在常量池（字符串池）创建存储进一个值为”abc”的字符串对象。如果已经存在，则跳过这一步工作。</p>
<p>(4)将对象引用s指向字符串池当中的”abc“对象。</p>
<blockquote>
<p>String s = new String(”abc“)<br>的步骤则为：</p>
</blockquote>
<p>(1)定义了一个名为”s”的String类型的引用。</p>
<p>(2)检查在常量池中是否存在值为”abc”的字符串对象；</p>
<p>(3)如果不存在，则在常量池（字符串池）存储进一个值为”abc”的字符串对象。如果已经存在，则跳过这一步工作。</p>
<p>(4)在堆中创建存储一个”abc“字符串对象。</p>
<p>(5)将对象引用指向堆中的对象。</p>
<p>这里指的注意的是，采用new的方式，虽然是在堆中存储对象，但是也会在存储之前检查常量池中是否已经含有此对象，如果没有，则会先在常量池创建对象，然后在堆中创建这个对象的”拷贝对象“。这也就是为什么有道面试题：</p>
<blockquote>
<p>String s = new String(“xyz”);   </p>
</blockquote>
<p>产生几个对象？的答案是：一个或两个的原因。因为如果常量池中原来没有”xyz”,就是两个。</p>
<p>弄清楚了原理，再看上面的例子，就知道为什么了。在执行String s1 = ‘abc”时;常量池中还没有对象，所以创建一个对象。之后在执行String s2 = ‘abc”的时候，因为常量池中已经存在了”abc’对象，所以说s2只需要指向这个对象就完成工作了。那么s1和s2指向同一个对象,用”==“比较自然返回true。所以常量池与栈内存一样，也可以实现数据共享。</p>
<p>还有值得注意的一点的就是：我们知道局部变量存储于栈内存当中。<br>那么成员变量呢？答案是：<em>成员变量的数据存储于堆中该成员变量所属的对象里面</em>。</p>
<p>而栈内存与堆内存的另一不同点在于，堆内存中存放的变量都会进行默认初始化，而栈内存中存放的变量却不会。<br>这也就是为什么，我们在声明一个成员变量时，可以不用对其进行初始化赋值。而如果声明一个局部变量却未进行初始赋值，如果想对其进行使用就会报编译异常的原因了。</p>
<hr>
<h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BirthDate</span> </span>&#123;    </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> day;    </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> month;    </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> year;        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">BirthDate</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> y)</span> </span>&#123;    </span><br><span class="line">           day = d;     </span><br><span class="line">           month = m;     </span><br><span class="line">           year = y;    </span><br><span class="line">       &#125;    </span><br><span class="line">       省略get,set方法………    </span><br><span class="line">   &#125;    </span><br><span class="line">       </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;    </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;    </span><br><span class="line">            <span class="keyword">int</span> date = <span class="number">9</span>;    </span><br><span class="line">            Test test = <span class="keyword">new</span> Test();          </span><br><span class="line">            test.change(date);     </span><br><span class="line">            BirthDate d1= <span class="keyword">new</span> BirthDate(<span class="number">7</span>,<span class="number">7</span>,<span class="number">1970</span>);           </span><br><span class="line">       &#125;      </span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;    </span><br><span class="line">           i = <span class="number">1234</span>;    </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><img src="java-memory/java_memory.png" alt=""></p>
<p>对于以上这段代码，date为局部变量，i,d,m,y都是形参为局部变量，day，month，year为成员变量。下面分析一下代码执行时候的变化：</p>
<p>main方法开始执行：int date = 9;<br>date局部变量，基础类型，引用和值都存在栈中。<br>Test test = new Test();<br>test为对象引用，存在栈中，对象(new Test())存在堆中。<br>test.change(date);<br>调用change(int i)方法，i为局部变量，引用和值存在栈中。当方法change执行完成后，i就会从栈中消失。<br>BirthDate d1= new BirthDate(7,7,1970);<br>调用BIrthDate类的构造函数生成对象。<br>d1为对象引用，存在栈中；<br>对象(new BirthDate())存在堆中；<br>其中d,m,y为局部变量存储在栈中，且它们的类型为基础类型，因此它们的数据也存储在栈中；<br>day,month,year为BirthDate对象的的成员变量，它们存储在堆中存储的new BirthDate()对象里面；<br>当BirthDate构造方法执行完之后，d,m,y将从栈中消失。<br>main方法执行完之后。<br>date变量，test，d1引用将从栈中消失；<br>new Test(),new BirthDate()将等待垃圾回收器进行回收。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/2020/04/04/about/</url>
    <content><![CDATA[<blockquote>
<p>A Coder, live in BJ, China.</p>
</blockquote>
<p>姓名：石帮玉<br>现居：北京<br>QQ: <a href="http://wpa.qq.com/msgrd?v=3&uin=2427075279&site=qq&menu=yes" target="_blank" rel="noopener">2427075279</a><br>微信: shi2427075279</p>
<a id="more"></a>]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown学习</title>
    <url>/2020/04/04/markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>Markdown 是一种轻量级标记语言，具有纯文本格式语法。</p>
</blockquote>
<p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。<br>用于编写说明文档，并且以“README.md”的文件名保存在软件的目录下面。<br>除此之外，由于我们有了RStudio这样的神级编辑器，我们还可以快速将Markdown转化为演讲PPT、Word产品文档、LaTex论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown已经广泛使用，极大地推进了动态可重复性研究的历史进程。</p>
<p>相信我；一旦你学会使用 Markdown，每一项写作任务在某种程度上都会比以前更容易、更好。让我们开始吧。<a id="more"></a></p>
<h2 id="标题使用"><a href="#标题使用" class="headerlink" title="标题使用"></a>标题使用</h2><h3 id="标题有两种表现方式"><a href="#标题有两种表现方式" class="headerlink" title="标题有两种表现方式"></a>标题有两种表现方式</h3><h3 id="1-使用‘-’和‘-’分别表示一级和二级标题（只能表示两种标题）"><a href="#1-使用‘-’和‘-’分别表示一级和二级标题（只能表示两种标题）" class="headerlink" title="1.使用‘=’和‘-’分别表示一级和二级标题（只能表示两种标题）"></a>1.使用‘=’和‘-’分别表示一级和二级标题（只能表示两种标题）</h3><p>例如：</p>
<p> 一级标题</p>
<p> =======</p>
<p> 二级标题</p>
<p>------</p>
<hr>
<h3 id="2-使用‘-’表示1-6级标题，‘-’个数即代表几级标题"><a href="#2-使用‘-’表示1-6级标题，‘-’个数即代表几级标题" class="headerlink" title="2.使用‘#’表示1-6级标题，‘#’个数即代表几级标题"></a>2.使用‘#’表示1-6级标题，‘#’个数即代表几级标题</h3><p>例如：</p>
<p> # 一级标题</p>
<p> ## 二级标题</p>
<p> ### 三级标题</p>
<p> #### 四级标题</p>
<hr>
<h2 id="段落格式使用"><a href="#段落格式使用" class="headerlink" title="段落格式使用"></a>段落格式使用</h2><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>段落换行使用两个空格加上回车即可，也可以在短落后增加一个空行实现换行</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>字体有斜体，粗体等  </p>
<p>*斜体文本*</p>
<p>_斜体文本_</p>
<p>**粗体文本**</p>
<p>__粗体文本__</p>
<p>***粗斜体文本***</p>
<p>___粗斜体文本___</p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。每种写法都可以建立分隔线：</p>
<p>***</p>
<p>* * *</p>
<p>******</p>
<p>- - -</p>
<p>---------</p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果文字上需要增加删除线，只需在文字两端各添加两个波浪线即可</p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>文本[^脚注]</p>
<p>[^脚注]：hello world</p>
<hr>
<h2 id="列表使用"><a href="#列表使用" class="headerlink" title="列表使用"></a>列表使用</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用 * ，+ ，- 来标记</p>
<p>* 第一项</p>
<p>* 第二项</p>
<p>+ 第一项</p>
<p>+ 第二项</p>
<p>- 第一项</p>
<p>-第二项</p>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字并加上 . 号来表示</p>
<ol>
<li><p>第一项</p>
</li>
<li><p>第二项</p>
</li>
</ol>
<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套需在<strong>子列表</strong>的选项添加<strong>4</strong>个空格即可</p>
<hr>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块引用在段落开头使用 ‘&gt;’ 符号，然后后面紧跟一个<strong>空格</strong>符号</p>
<p>区块是可以嵌套的，一个 ‘&gt;’ 符号是最外层，两个 ‘&gt;’ 符号是第一层嵌套，以此类推</p>
<p>&gt; 最外层</p>
<p>&gt; &gt; 第一层嵌套</p>
<p>&gt; &gt; &gt; 第二层嵌套</p>
<p>区块中使用列表</p>
<p>&gt; 区块中使用列表</p>
<p>&gt; 1. 第一项</p>
<p>&gt; 2. 第二项</p>
<p>&gt; + 第一项</p>
<p>&gt; + 第二项</p>
<p>&gt; + 第三项</p>
<p>列表中使用区块</p>
<p>* 第一项<br>    &gt; hello<br>    &gt; world<br>* 第二项</p>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p>
<blockquote>
<p>`print()`函数</p>
</blockquote>
<p>代码区块使用4个空格符号或者一个tab键，也可使用```包裹一段代码，并指定一种语言（也可以不指定）</p>
<pre><code>public static void main(String[] args){      
  Systemr.out.print(&quot;haha&quot;);  
};</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  	</span><br><span class="line">  System.out.print(<span class="string">"haha"</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>使用方法如下</p>
<p>[链接名称](链接地址) 或者 &lt;链接地址&gt;</p>
<p>这是一个链接 [test](<a href="https://www.test.com" target="_blank" rel="noopener">https://www.test.com</a> )</p>
<p>&lt; <a href="https://www.runoob.com" target="_blank" rel="noopener">https://www.runoob.com</a> &gt;</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="markdown%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E7%89%87.png" alt=""></p>
<p><img src="markdown%E5%AD%A6%E4%B9%A0/img%E6%A0%87%E7%AD%BE.png" alt=""></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p>
<p>|  表头   | 表头  |<br>|  —-  | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |</p>
<h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><p>我们可以设置表格的对齐方式：</p>
<p>-: 设置内容和标题栏居右对齐。</p>
<p>:- 设置内容和标题栏居左对齐。</p>
<p>:-: 设置内容和标题栏居中对齐。</p>
<p><img src="markdown%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E9%BD%90.png" alt=""></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
